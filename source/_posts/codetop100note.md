---
title: codetop 100题（暂定） 思路笔记
date: 2023-12-01 15:55:45
tags: leetcode
---
## 两数之和
题目条件说答案唯一，hash表存target-x即可。
时间：O(N)，空间：O(N)

## 三数之和
基本思路是遍历数组对每个值求两数之和，易知时间复杂度必为O(N^2)。

题目要求答案不可重复，但是数组中会出现重复值，如[1,2,-3,2]，使用hash表扫一遍还要去重，所以不使用hash表。

因此先排序，再使用双指针从两端遍历，双指针可以跳过重复的值。

时间：O(NlogN)+O(N^2)=O(N^2)，空间：O(1)

## 最大连续子序和
> 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

### DP
DP最优，遍历一遍，直观理解是当前序列之和<0就可以从下一个大于0的元素开始继续遍历，转移方程为：
$$ f(i)=max\{f(i-1)+nums[i],nums[i]\} $$
时间：O(N)，空间：O(1)
### 线段树
区间求和就用线段树喵~线段树可以求任意区间最大和，存了其他区间信息所以空间复杂度会高一点。

时间：O(N)，空间：O(logN)

## 最长回文子串
典中典DP，从下到上，从左到右，遍历上三角状态转移矩阵。

时间：O(N^2)，空间：O(N^2)，也可以不存具体矩阵，从状态[i,i]往右上角一路转移，这时空间：O(1)。

Manacher算法可以达到O(N)的时空复杂度，不看。

## 搜索旋转排序数组
> 整数数组 nums 按升序排列，数组中的值 互不相同 。
> 
> 在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
> 
> 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

二叉查找

时间：O(logN)，空间：O(1)

## 检测环形链表
快慢指针，快指针一次两格，慢指针一次一格。若快慢指针相遇了则链表有环。

经过数学计算，用另两个指针从快慢指针相遇节点和头节点同时前进，最终相遇的节点为环入口。

时间：O(N)，空间：O(1)

## 岛屿数量
> 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
> 
> 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
> 
> 此外，你可以假设该网格的四条边均被水包围。

BFS|DFS|并查集

时间：O(MN)，空间：O(MN)，BFS空间为O(min(M,N))

## LCA（最近公共祖先）树
递归。

时间：O(N)，空间：O(N)

## 和为K的子数组
前缀和

时间：O(N)，空间：O(N)

## 2d接雨水

## 螺旋矩阵
> 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

**按层（圈）模拟**，可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。

时间：O(MN)，空间：O(1)

## 螺旋矩阵 II
> 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。

还是**绕圈圈**。
时间：O(N^2)，空间：O(1)

## 相交链表
> 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。

**双指针**，a指针遍历完headA遍历headB，b指针遍历完headB遍历headA，两者遍历长度相等，最终会相遇在相交节点处。没相遇就是没相交。

时间：O(M+N)，空间：O(1)

## 最长递增子序列
>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
> 
> **子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

### DP
时间：O(N^2)，空间：O(N)
### 贪心+二分查找
维护一个数组d，d[i]表示长度为i的所有子序列末尾元素最小的。每一步都将当前值插入d数组，将由于d本身递增，所以可以使用二分查找达到logN的插入效率。

以输入序列 [90,100,1,101,102]为例：
- 第一步插入 90，d=[90]；
- 第二步插入 100，d=[90,100]；
- 第三步插入 1，d=[1,100]；
- 第四步插入 101，d=[1,100,101]；
- 第五步插入 102，d=[1,100,101,102]。

再以输入序列 [90,100,1,2,3]为例：
- 第一步插入 90，d=[90]；
- 第二步插入 100，d=[90,100]；
- 第三步插入 1，d=[1,100]；
- 第四步插入 2，d=[1,2]；
- 第五步插入 3，d=[1,2,3]。

d数组并不是最终子序列结果，但是其长度是最长子序列的长。这相当于将所有可能的递增子序列重叠在了一起。

时间：O(NlogN)，空间：O(N)

## 合并区间
> **输入**：intervals = [[1,3],[2,6],[8,10],[15,18]]
> 
> **输出**：[[1,6],[8,10],[15,18]]
> 
> **解释**：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

按照区间的左端点排序，那么在排完序的列表中，可以合并的区间一定是连续的。

时间：O(NlogN)，空间：O(logN)，空间为排序所需空间

## 二叉树中的最大路径和
![lc124例子](../img/codetop/lc124.jpg)
> **输入**：root = [-10,9,20,null,null,15,7]
> 
> **输出**：42
> 
> **解释**：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42

保存每个节点的最大路径和，即
$$ pv_{max}=pv+max(lv,rv) $$
最大路径和则是
$$ v_{max}=max\{pv_{max},pv+lv+rv\} $$
要么是从某个节点往下延伸的一长条，要么是某个节点连着自身两棵子树的组成的三角形（？）。

## x的平方根
二分、Newton迭代

## 重排链表
> 给定一个单链表 L 的头节点 head ，单链表 L 表示为：
> 
> $$ L_0 → L_1 → … → L_{n - 1} → L_n $$
> 请将其重新排列后变为：
> 
> $$ L_0 → L_n → L_1 → L_{n - 1} → L_2 → L_{n - 2} → … $$
> 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

快慢指针找中点，分裂成两条链表，反转后半段链表，进行交叉合并。

时间：O(N)，空间：O(1)

## 排序链表
> 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。

自底向上归并排序。

时间：O(NlogN)，空间：O(1)

## 编辑距离
> 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。
> 
> 你可以对一个单词进行如下三种操作：
> 
> - 插入一个字符
> - 删除一个字符
> - 替换一个字符

### DP

D[i][j]代表w1[0..i]和w2[0...j]的编辑距离。

以A=horse，B=ros为例。若A[i]和B[j]不等，其更新有以下三种情况：
- 在单词 A 中插入一个字符：如果我们知道 horse 到 ro 的编辑距离为 a，那么显然 horse 到 ros 的编辑距离不会超过 a + 1。这是因为我们可以在 a 次操作后将 horse 和 ro 变为相同的字符串，只需要额外的 1 次操作，在单词 A 的末尾添加字符 s，就能在 a + 1 次操作后将 horse 和 ro 变为相同的字符串；
- 在单词 B 中插入一个字符：如果我们知道 hors 到 ros 的编辑距离为 b，那么显然 horse 到 ros 的编辑距离不会超过 b + 1，原因同上；

- 修改单词 A 的一个字符：如果我们知道 hors 到 ro 的编辑距离为 c，那么显然 horse 到 ros 的编辑距离不会超过 c + 1，原因同上。

那么从 horse 变成 ros 的编辑距离应该为 
$$ D[i][j]=min\{D[i-1][j],D[i][j-1],D[i-1][j-1]\} + 1 $$
若A[i]==B[j]，同理推导，则
$$ D[i][j]=min\{D[i-1][j],D[i][j-1],D[i-1][j-1]-1\} + 1 $$

时间：O(MN)，空间：O(MN)，因为D[i][j]只依赖left\left-top\top的状态，所以也可以压缩状态矩阵空间为O(min\{M,N\})

## 最长公共子序列
> 给定两个字符串 text1 和 text2，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 0 。
> 
> 一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
> 
> - 例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
> 
> 两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

### DP

D[i][j]代表w1[0..i]和w2[0...j]的最长公共子序列长度。
$$
D[i][j]=\left\{
    \begin{align}
        & D[i-1][j-1]+1,              & test_1[i-1]=text_2[j-1], \\
        & max\{D[i-1][j],D[i][j-1]\}, & test_1[i-1]\not =text_2[j-1]
    \end{align}
\right.     
$$

时间：O(MN)，空间：O(MN)，同 [编辑距离](#编辑距离) ，只依赖left\left-top\top的状态，可压缩为O(min\{M,N\})